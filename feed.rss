<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>OddMagnet.dev</title><description>Eine deutschsprachige Webseite rund um die Programmiersprache Swift</description><link>https://oddmagnet.dev</link><language>de</language><lastBuildDate>Sun, 20 Feb 2022 08:32:02 +0100</lastBuildDate><pubDate>Sun, 20 Feb 2022 08:32:02 +0100</pubDate><ttl>250</ttl><atom:link href="https://oddmagnet.dev/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://oddmagnet.dev/posts/Die%20Erstellung%20dieser%20Seite%20-%20Teil%204</guid><title>Eine deutsche Webseite über Swift, erstellt mit Swift - Teil 4</title><description>Wie diese Seite erstellt wurde, Teil 4.</description><link>https://oddmagnet.dev/posts/Die%20Erstellung%20dieser%20Seite%20-%20Teil%204</link><pubDate>Tue, 8 Feb 2022 16:25:00 +0100</pubDate><content:encoded><![CDATA[<h1>Eine deutsche Webseite über Swift, erstellt mit Swift - Teil 4</h1><p>In diesem letzten Teil geht es nun um das hinzufügen von CSS, üblicherweise würde sowas keinen eigenen Teil kriegen, aber da ich Sass benutze und auch zeigen möchte wie man das mit Publish macht gibt es nun einen Teil 4. Ansonsten wir üblich die Anmerkung dass diese Reihe von Posts eher auf einem Anfänger-Niveau sein wird / soll.</p><p>Mit Design bin ich persönlich auf Kriegsfuß, entweder ich verbringe wortwörtlich Stunden mit einem kleinen Detail (und schaffe es dann dennoch nicht dass es mir gefällt), oder ich übertreibe komplett und heraus kommt ein absolutes Design-Monster. Für diese Website habe ich mich entschieden möglichst minimalistisch zu bleiben, hoffentlich sieht die damit nicht nur in meinen Augen akzeptabel aus.</p><p>Bevor es losgeht noch eine letzte Abschweifung.</p><h2>Ein neues Plugin</h2><p>Das Splash-Plugin ist super, wenn es nur um das Syntax-Highlighting von Swift geht. Da ich aber immer gerne etwas extra Aufwand betreibe um Zukunftssicher zu sein habe ich nach einem Plugin gesucht was mehrere Sprachen unterstützt.</p><p>Dieses habe ich mit dem <a href="https://github.com/nerdsupremacist/syntax-highlight-publish-plugin.git">"Syntax Highlight Publish Plugin"</a> gefunden. Dieses erfordert ein klein wenig mehr Finesse beim hinzufügen zur <code>Package.swift</code> Datei.</p><pre><code><span class="keyword">let</span> package = <span class="type">Package</span>(
  name: <span class="string">"OddmagnetDev"</span>,
  products: [ <span class="comment">/*…*/</span> ],
  dependencies: [
    .<span class="call">package</span>(name: <span class="string">"Publish"</span>, url: <span class="string">"https://github.com/johnsundell/publish.git"</span>, from: <span class="string">"0.7.0"</span>),
    .<span class="call">package</span>(url: <span class="string">"https://github.com/nerdsupremacist/syntax-highlight-publish-plugin.git"</span>, from: <span class="string">"0.1.0"</span>),
  ],
  targets: [
    .<span class="call">target</span>(
      name: <span class="string">"OddmagnetDev"</span>,
      dependencies: [
        <span class="string">"Publish"</span>,
        <span class="comment">// Hier der wichtige Part, man muss es als .product(...) hinzufügen</span>
        .<span class="call">product</span>(name: <span class="string">"SyntaxHighlightPublishPlugin"</span>, package: <span class="string">"syntax-highlight-publish-plugin"</span>),
      ]
    )
  ]
)
</code></pre><p>Dies nutzt man nun ähnlich wie das Splash Plugin in der Publish Pipeline:</p><pre><code>.<span class="call">installPlugin</span>(.<span class="call">syntaxHighlighting</span>([.<span class="dotAccess">swift</span>])),
</code></pre><p>Mit dem Hauptunterschied dass man als Argumente noch die Sprachen angibt um die sich das Plugin kümmern soll.</p><p>Standardmäßig kommt das Plugin mit support für Swift, aber wie auf der Github Seite des Plugins beschrieben kann man auch relativ einfach weitere Sprachen hinzufügen - solange man an eine <code>.tmLanguage</code> Datei für die Sprache rankommt.</p><h2>Ein 'sassy' Plugin</h2><p>Damit man <code>Sass</code> anstatt <code>CSS</code> nutzen - oder besser gesagt in die Pipeline einbauen kann - braucht man ein weiteres <a href="https://github.com/nerdsupremacist/syntax-highlight-publish-plugin.git">Plugin</a>, hier die relevanten Zeilen in der <code>Package.swift</code> Datei:</p><pre><code><span class="keyword">let</span> package = <span class="type">Package</span>(
  <span class="comment">/*…*/</span>
  dependencies: [
    <span class="comment">/*…*/</span>
    .<span class="call">package</span>(url: <span class="string">"https://github.com/hejki/sasspublishplugin.git"</span>, from: <span class="string">"0.1.0"</span>)
  ],
  targets: [
    .<span class="call">target</span>(
      name: <span class="string">"OddmagnetDev"</span>,
      dependencies: [
        <span class="comment">/*…*/</span>
        .<span class="call">product</span>(name: <span class="string">"SassPublishPlugin"</span>, package: <span class="string">"sasspublishplugin"</span>)
      ]
    )
  ]
)
</code></pre><p><strong>Wichtig</strong>: neben dem hinzufügen des Packets muss man auch <code>libsass</code> installieren: <code>$ brew install libsass</code></p><p>Schlussendlich muss man das Plugin dann nur noch in der <code>main.swift</code> Datei importieren und installieren:</p><pre><code><span class="comment">/* andere Imports ausgelassen */</span>
<span class="keyword">import</span> SassPublishPlugin

<span class="keyword">struct</span> OddmagnetDev: <span class="type">OddWebsite</span> { <span class="comment">/*…*/</span> }

<span class="keyword">try</span> <span class="type">OddmagnetDev</span>().<span class="call">publish</span>(using: [
  <span class="comment">/* andere Schritte in der Pipeline ausgelassen */</span>
  .<span class="call">installPlugin</span>(
    .<span class="call">compileSass</span>(
      sassFilePath: <span class="string">"Resources/OddTheme/sass/styles.sass"</span>,
      cssFilePath: <span class="string">"styles.css"</span>
    )
  )
])
</code></pre><p><strong>Wichtig:</strong> meine Theme nutzt den standard <code>.head()</code> von Publish, welcher ohne weitere Angabe einfach die <code>styles.css</code> im Root-Verzeichnis nutzt. Wenn ihr eure CSS Datei woanders haben wollt müsst ihr nicht nur beim Plugin den Pfad ändern, sondern auch in eurer Theme.</p><h2>Schlusswort</h2><p>Das war es erstmal für diese Eröffnungsreihe von Posts für meine Seite. Wie schon im ersten Teil erwähnt bin ich bei weitem kein Experte (und schon recht kein Designer). Es gibt noch viel zu tun bevor diese Seite (und auch meine Theme) auf dem Stand sind wo ich sie sehen möchte.</p><p>Wenn ihr Fragen oder Feedback habt, oder mir gar helfen wollt, schreibt mir einfach eine E-Mail. Schlussendlich ist eins meiner Ziele mit dieser Seite ja auch den Kontakt zu anderen deutschen Entwicklern aufzubauen :)</p>]]></content:encoded></item><item><guid isPermaLink="true">https://oddmagnet.dev/posts/Die%20Erstellung%20dieser%20Seite%20-%20Teil%203</guid><title>Eine deutsche Webseite über Swift, erstellt mit Swift - Teil 3</title><description>Wie diese Seite erstellt wurde, Teil 3.</description><link>https://oddmagnet.dev/posts/Die%20Erstellung%20dieser%20Seite%20-%20Teil%203</link><pubDate>Tue, 8 Feb 2022 16:24:00 +0100</pubDate><content:encoded><![CDATA[<h1>Eine deutsche Webseite über Swift, erstellt mit Swift - Teil 3</h1><p>Wie im letzten Teil schon erwähnt dreht sich dieser Teil hauptsächlich um das hinzufügen eines eigenen Themes. Ansonsten wir üblich die Anmerkung dass diese Reihe von Posts eher auf einem Anfänger-Niveau sein wird / soll.</p><p>Was ich ursprünglich vermeiden wollte war es meine Theme selber zu erstellen, da ich von Design wenig Ahnung habe. Mit jeder zusätzlichen Zeile CSS erhöht sich die Wahrscheinlichkeit dass meine Website nachher einfach grausam aussieht.</p><p>Wie man das als Entwickler dann halt so macht googlet man erstmal nach vorhandenen Lösungen für das eigene Problem. Wirklich viel finden wird man allerdings nicht. Publish ist vergleichsweise relativ unbekannt. Die Blogs deren Code man auf Github einsehen kann haben alle kaum Änderungen in der Theme und von denen, die sich wirklich abheben, kann man den Code nicht einsehen.</p><p>Bleibt also nur übrig, doch eine eigene Theme zu erstellen.</p><h2>Die Basics</h2><p>Um eine eigene Theme für Publish zu erstellen benötigt man einige Sachen:</p><ul><li>Ein Protokoll für die eigene Theme, wenn man extra Funktionen einbauen will</li><li>Eine HTMLFactory, die das HTML für die Seite erzeugt</li><li>Eine Extension auf Theme, in der man dann in einer statische Variable seine Theme inklusive HTMLFactory bereit stellt.</li></ul><p>Für diesen Post werde ich das ganze von hinten auflösen, die Extension selber ist das einfachste und benötigt nur einige wenige Zeilen:</p><h3>Extension auf Theme</h3><pre><code><span class="keyword">public extension</span> <span class="type">Theme</span> <span class="keyword">where</span> <span class="type">Site</span>: <span class="type">OddWebsite</span> {	<span class="comment">// 1</span>
  <span class="keyword">static var</span> oddTheme: <span class="type">Self</span> {										<span class="comment">// 2</span>
    <span class="type">Theme</span>(																			<span class="comment">// 3</span>
      htmlFactory: <span class="type">OddThemeHTMLFactory</span>(),
      ressourcePaths: []
    )
  }
}
</code></pre><ol><li>Hier lege ich fest dass die Website die meine Theme nutzen will auch zu meinem <code>OddWebsite</code> Protokoll konform sein muss. Dazu später mehr.</li><li>Die statische Variable legt auch den Namen der Theme fest, wie man ihn in der Publish Pipeline später nutzt</li><li>Damit die Theme das HTML "bauen" kann braucht sie natürlich eine HTMLFactory. Interessanter hier sind die <code>ressourcePaths</code>, diese sind absichtlich leer bei mir, da der <code>.head()</code> component von Publish standardmäßig die <code>styles.css</code> im Root-Directory nutzt. Auch dazu später mehr.</li></ol><h3>Eigene HTMLFactory</h3><p>Wirklich viel zu sagen gibt es dazu für meine Seite nicht, da das HTML sehr ähnlich zu dem der 'Foundation' Theme bleibt. Dennoch möchte ich kurz ein paar Worte zu den Funktionen der Factory verlieren und auch kurz, in den Kommentaren, beschreiben was ich denn abgeändert habe.</p><pre><code><span class="keyword">private struct</span> OddThemeHTMLFactory&lt;Site: <span class="type">OddWebsite</span>&gt;: <span class="type">HTMLFactory</span> {
  <span class="comment">// Erzeugt das HTML für den Index der Seite
  // Nur kleine Änderungen, wie das entfernen eines Paragraphens und Headings</span>
  <span class="keyword">func</span> makeIndexHTML(for index: <span class="type">Index</span>, context: <span class="type">PublishingContext</span>&lt;<span class="type">Site</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> { <span class="comment">/*…*/</span> }
  
  <span class="comment">// Erzeugt das HTML für die einzelnen Sektionen, keine Änderungen</span>
  <span class="keyword">func</span> makeSectionHTML(for section: <span class="type">Section</span>&lt;<span class="type">Site</span>&gt;, context: <span class="type">PublishingContext</span>&lt;<span class="type">Site</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> { <span class="comment">/*…*/</span>}

  <span class="comment">// Erzeugt das HTML für den Inhalt des Blogs, sprich die .md Dateien 
  // Zeigt zusätzlich das Datum und die Zeit des Artikels an</span>
  <span class="keyword">func</span> makeItemHTML(for item: <span class="type">Item</span>&lt;<span class="type">Site</span>&gt;, context: <span class="type">PublishingContext</span>&lt;<span class="type">Site</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> { <span class="comment">/*…*/</span> }
  <span class="comment">// Erzeugt das HTML für die einzelnen Seite, wie z.B. die "Über mich" Seite
  // Noch keine Änderungen</span>
  <span class="keyword">func</span> makePageHTML(for page: <span class="type">Page</span>, context: <span class="type">PublishingContext</span>&lt;<span class="type">Site</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> { <span class="comment">/*…*/</span> }

  <span class="comment">// Erzeugt das HTML für die Tag Liste, eine Übersicht aller Tags
  // Noch keine Änderungen</span>
  <span class="keyword">func</span> makeTagListHTML(for page: <span class="type">TagListPage</span>, context: <span class="type">PublishingContext</span>&lt;<span class="type">Site</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span>? { <span class="comment">/*…*/</span> }

  <span class="comment">// Erzeugt das HTML für die Tag Details, eine Übersicht aller Posts mit einem Tag
  // Noch keine Änderungen</span>
  <span class="keyword">func</span> makeTagDetailsHTML(for page: <span class="type">TagDetailsPage</span>, context: <span class="type">PublishingContext</span>&lt;<span class="type">Site</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span>? { <span class="comment">/*…*/</span> }
}
</code></pre><p>Interessant hierbei ist, dass die letzten beiden Funktionen nicht unbedingt einen Rückgabewert haben müssen. Das ist dann nützlich wenn die Theme die man sich baut keine Tags unterstützen soll.</p><p>Neben diesen Methoden gibt es auch noch Helfer-Structs, <code>Wrapper</code> erzeugt einfach nur ein <code>Div</code> mit der Klasse 'wrapper', <code>SiteFooter</code> erzeugt den Footer, <code>ItemList</code> erzeugt eine Liste von allen Posts und <code>ItemTagList</code> eine Liste von allen Tags die ein Post hat.</p><p>Was ich für meine Theme noch angepasst habe ist der <code>SiteHeader</code>, <code>/*…*/</code> stehen für Code der unverändert blieb.</p><pre><code><span class="keyword">private struct</span> SiteHeader&lt;Site: <span class="type">OddWebsite</span>&gt;: <span class="type">Component</span> {
  <span class="keyword">var</span> context: <span class="type">PublishingContext</span>&lt;<span class="type">Site</span>&gt;
  <span class="keyword">var</span> selectedSectionID: <span class="type">Site</span>.<span class="type">SectionID</span>?

  <span class="keyword">var</span> body: <span class="type">Component</span> {
    <span class="type">Header</span> {
      <span class="type">Wrapper</span> {
        <span class="type">H1</span>( <span class="comment">/*…*/</span> )
        
        <span class="comment">// Die Seitenbeschreibung ist nun im Header für meine Theme</span>
        <span class="type">Span</span>(context.<span class="property">site</span>.<span class="property">description</span>).<span class="call">class</span>(<span class="string">"description"</span>)

        <span class="keyword">if</span> <span class="type">Site</span>.<span class="type">SectionID</span>.<span class="property">allCases</span>.<span class="property">count</span> &gt; <span class="number">1</span> { <span class="comment">/*…*/</span> }

        <span class="comment">// Zusätzlich bietet meine Theme nun einen Bereich für "soziale" Links
        // z.B. Github, Twitter, LinkedIn, E-Mail und später vielleicht noch mehr</span>
        socials
      }
    }
  }

  <span class="keyword">var</span> navigation: <span class="type">Component</span> { <span class="comment">/*…*/</span> }
  
  <span class="keyword">var</span> socials: <span class="type">Component</span> {
    <span class="type">Navigation</span> {
      <span class="type">List</span>(context.<span class="property">site</span>.<span class="property">contacts</span>) { (contactPoint, handler) <span class="keyword">in</span>
				<span class="type">Link</span>(url: contactPoint.<span class="call">url</span>(handler)) {
          contactPoint.<span class="property">svg</span>
        }.<span class="call">class</span>(<span class="string">"contact-svg"</span>)
			}
      .<span class="call">class</span>(<span class="string">"share"</span>)
    }
  }
}
</code></pre><p>Neu bei der <code>socials</code> Komponente ist, dass sie die <code>contacts</code> variable meiner Seite nutzt, etwas was durch das <code>OddWebsite</code> Protokoll vorgegeben wird.</p><h3>Das eigene Protokoll</h3><p>Durch ein eigenes Protokoll kann man in der Theme dann auch mehr machen, z.B. auf ein Array von Kontaktdaten zugreifen.</p><pre><code><span class="keyword">public protocol</span> OddWebsite: <span class="type">Website</span> {
  <span class="keyword">var</span> contacts: [(<span class="type">ContactPoint</span>, <span class="type">String</span>)] { <span class="keyword">get</span> }
}

<span class="keyword">public enum</span> ContactPoint {
  <span class="keyword">case</span> twitter, github, linkedin, mail
  
  <span class="keyword">func</span> url(<span class="keyword">_</span> handler: <span class="type">String</span>) -&gt; <span class="type">String</span> {
    <span class="keyword">switch self</span> {
      <span class="keyword">case</span> .<span class="dotAccess">twitter</span>:
      	<span class="keyword">return</span> <span class="string">"https://twitter.com/</span>\(handler)<span class="string">"</span>
      <span class="keyword">case</span> .<span class="dotAccess">github</span>:
      	<span class="keyword">return</span> <span class="string">"https://github.com/</span>\(handler)<span class="string">"</span>
      <span class="keyword">case</span> .<span class="dotAccess">linkedin</span>:
      	<span class="keyword">return</span> <span class="string">"https://www.linkedin.com/in/</span>\(handler)<span class="string">/"</span>
      <span class="keyword">case</span> .<span class="dotAccess">mail</span>:
      	<span class="keyword">return</span> <span class="string">"mailto:</span>\(handler)<span class="string">"</span>
    }
  }
  
  <span class="keyword">var</span> svg: <span class="type">Node</span>&lt;<span class="type">HTML</span>.<span class="type">AnchorContext</span>&gt; {
    <span class="keyword">switch self</span> {
      <span class="keyword">case</span> .<span class="dotAccess">twitter</span>:
      	<span class="keyword">return</span> .<span class="call">element</span>(<span class="comment">/* SVG für das Twitter icon */</span>)
      <span class="keyword">case</span> .<span class="dotAccess">github</span>:
      	<span class="keyword">return</span> .<span class="call">element</span>(<span class="comment">/* SVG für das Github Icon */</span>)
      <span class="keyword">case</span> .<span class="dotAccess">linkedin</span>:
      	<span class="keyword">return</span> .<span class="call">element</span>(<span class="comment">/* SVG für das LinkedIn Icon */</span>)
      <span class="keyword">case</span> .<span class="dotAccess">mail</span>:
      	<span class="keyword">return</span> .<span class="call">element</span>(<span class="comment">/* SVG für das E-Mail Icon */</span>)
    }
  }
}
</code></pre><p>Langfristig will ich die Theme auch als Paket anbieten, dafür muss das Protokoll und auch die Kontaktmöglichkeiten natürlich noch viel erweitert werden. Ich freue mich natürlich über jegliche Hilfe beim Erreichen dieses Ziels.</p><p>Damit meine Theme funktioniert brauche ich nun nur noch meine Website Klasse konform dazu machen:</p><pre><code><span class="keyword">struct</span> OddmagnetDev: <span class="type">OddWebsite</span> {
  <span class="keyword">var</span> contacts: [(<span class="type">ContactPoint</span>, <span class="type">String</span>)] {
    [
      (.<span class="dotAccess">twitter</span>, <span class="string">"OddMagnetDev"</span>),
      (.<span class="dotAccess">github</span>, <span class="string">"OddMagnet"</span>),
      (.<span class="dotAccess">linkedin</span>, <span class="string">"OddMagnet"</span>),
      (.<span class="dotAccess">mail</span>, <span class="string">"mibruenen@gmail.com"</span>)
    ]
  }
  
  <span class="comment">/* Die restlichen Variablen die eine Publish-Seite braucht sind ausgelassen */</span>
}

<span class="comment">// In der Publish Pipeline muss dann nur noch die eigene Theme genutzt werden</span>
<span class="keyword">try</span> <span class="type">OddmagnetDev</span>().<span class="call">publish</span>(using: [
  <span class="comment">/* andere Schritte ausgelassen */</span>
  .<span class="call">generateHTML</span>(withTheme: .<span class="dotAccess">oddTheme</span>),
  <span class="comment">/* andere Schritte ausgelassen */</span>
])
</code></pre><p>Im letzten Teil der Reihe werde ich noch kurz über eine kleine Änderung bei den Plugins, sowie das erstellen vom CSS für die Seite gehen.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://oddmagnet.dev/posts/Die%20Erstellung%20dieser%20Seite%20-%20Teil%202</guid><title>Eine deutsche Webseite über Swift, erstellt mit Swift - Teil 2</title><description>Wie diese Seite erstellt wurde, Teil 2.</description><link>https://oddmagnet.dev/posts/Die%20Erstellung%20dieser%20Seite%20-%20Teil%202</link><pubDate>Tue, 8 Feb 2022 16:23:00 +0100</pubDate><content:encoded><![CDATA[<h1>Eine deutsche Webseite über Swift, erstellt mit Swift - Teil 2</h1><p>In diesem Teil geht es um die Installation und Konfiguration des Splash Plugins für Publish, dieses findet man (unter anderem) hier: <a href="https://github.com/topics/publish-plugin?l=swift">Publish Community Plugins</a>. Wer selber ein Plugin für Publish entwickeln möchte sollte auf jeden Fall das <code>publish-plugin</code> topic zu dem Repository hinzufügen (siehe <a href="https://help.github.com/en/github/administering-a-repository/classifying-your-repository-with-topics#adding-topics-to-your-repository">hier</a>), dadurch ist das Plugin direkt bei den anderen Community Plugins aufzufinden. Wie in Teil 1 erwähnt wird diese Reihe von Posts eher auf einem Anfänger-Niveau sein.</p><h2>Installation am Beispiel von Splash</h2><p>Um ein Plugin zu nutzen muss man es zuerst zu den Dependencies in der <code>Package.swift</code> Datei hinzufügen, diese sieht direkt nach der Nutzung von <code>publish new</code> erstmal so aus:</p><pre><code><span class="keyword">let</span> package = <span class="type">Package</span>(
    name: <span class="string">"OddmagnetDev"</span>,
    products: [
        .<span class="call">executable</span>(
            name: <span class="string">"OddmagnetDev"</span>,
            targets: [<span class="string">"OddmagnetDev"</span>]
        )
    ],
    dependencies: [
        .<span class="call">package</span>(name: <span class="string">"Publish"</span>, url: <span class="string">"https://github.com/johnsundell/publish.git"</span>, from: <span class="string">"0.7.0"</span>)
    ],
    targets: [
        .<span class="call">target</span>(
            name: <span class="string">"OddmagnetDev"</span>,
            dependencies: [<span class="string">"Publish"</span>]
        )
    ]
)
</code></pre><p>Am Beispiel des <a href="https://github.com/JohnSundell/SplashPublishPlugin">Splash Plugins</a> sähe das dann so aus:</p><pre><code><span class="keyword">let</span> package = <span class="type">Package</span>(
    <span class="comment">/* Code ausgelassen */</span> 
    dependencies: [
        .<span class="call">package</span>(name: <span class="string">"Publish"</span>, url: <span class="string">"https://github.com/johnsundell/publish.git"</span>, from: <span class="string">"0.7.0"</span>),
        .<span class="call">package</span>(name: <span class="string">"SplashPublishPlugin"</span>, url: <span class="string">"https://github.com/johnsundell/splashpublishplugin"</span>, from: <span class="string">"0.1.0"</span>)
    ],
    targets: [
        .<span class="call">target</span>(
            name: <span class="string">"OddmagnetDev"</span>,
            dependencies: [
                <span class="string">"Publish"</span>,
                <span class="string">"SplashPublishPlugin"</span>
            ]
        )
    ]
)
</code></pre><p>Das allein reicht natürlich nicht aus, damit das Plugin auch was macht muss es in der publishing pipeline genutzt werden, in der <code>main.swift</code>:</p><pre><code><span class="comment">/* Vorherige imports ausgelassen */</span>
<span class="keyword">import</span> SplashPublishPlugin

<span class="keyword">struct</span> OddmagnetDev: <span class="type">Website</span> { <span class="comment">/*...*/</span> }

<span class="keyword">try</span> <span class="type">OddmagnetDev</span>().<span class="call">publish</span>(using: [
    .<span class="call">installPlugin</span>(.<span class="call">splash</span>(withClassPrefix: <span class="string">""</span>)),
  	<span class="comment">/* alle weiteren Schritte */</span>
])
</code></pre><h2>CSS Datei für Splash hinzufügen</h2><p>Im Falle von Splash wird auch noch eine <code>styles.css</code> Datei benötigt, für einen guten Startpunk empfehle ich die <a href="https://github.com/JohnSundell/Splash/blob/master/Examples/sundellsColors.css">Beispiel CSS Datei</a> von John Sundell.</p><p>Diese kann man leider nicht ohne weiteres nutzen, solange man die <code>Foundation</code> Theme verwendet. Idealerweise erstellt man sich seine eigene Theme in der die CSS Datei dann genutzt wird.</p><p>Da ich in einem späteren Beitrag über die Erstellung einer eigenen Theme gehen will zeige ich in diesem Artikel nur einen "Workaround" wie man die CSS Datei für das Syntax Highlighting auch mit dem <code>Foundation</code> Theme "nutzen" kann.</p><p>Zuerst erstellt man einen neuen Ordner für die "eigene" Theme <code>Resources &gt; ThemeName</code>, in diesem kommt dann die CSS Datei für das Publish plugin, ich habe sie einfach <code>splash.css</code> genannt. Zusätzlich erstellt man auch noch eine CSS Datei für die eigentliche Theme, <code>styles.css</code>, in diese kopiert man dann den Inhalt der von <code>Publish &gt; Resources &gt; FoundationTheme &gt; styles.css</code>.</p><p>Als nächstes erstellt man einen Ordner für den Code der "eigenen" Theme <code>Sources &gt; ProjektName &gt; ThemeName</code>, sowie eine <code>Theme+ThemeName.swift</code> Datei. Dort kopiert man den Inhalt von <code>Publish &gt; Sources &gt; Publish &gt; API &gt; Theme+Foundation.swift</code> rein.</p><p>Nun muss man diese Datei noch ein wenig anpassen, zum einen wird ein <code>import Publish</code> benötigt, zum anderen sollte man den Namen für die Theme ändern, sowie die Pfade für die CSS Dateien anpassen, das sollte dann so aussehen:</p><pre><code><span class="keyword">import</span> Plot
<span class="keyword">import</span> Publish

<span class="keyword">public extension</span> <span class="type">Theme</span> {
    <span class="keyword">static var</span> themeName: <span class="type">Self</span> { <span class="comment">// hier den Namen der Variable ändern</span>
        <span class="type">Theme</span>(
            htmlFactory: <span class="type">ThemeNameHTMLFactory</span>(),	<span class="comment">// den Factory Namen auch entsprechend anpassen</span>
            resourcePaths: [	<span class="comment">// und die Pfade für die CSS Dateien anpassen</span>
                <span class="string">"Resources/ThemeName/styles.css"</span>,
                <span class="string">"Resources/ThemeName/splash.css"</span>
                ]
        )
    }
}

<span class="comment">// Die Factory selber muss natürlich auch umbenannt werden</span>
<span class="keyword">private struct</span> ThemeNameHTMLFactory&lt;Site: <span class="type">Website</span>&gt;: <span class="type">HTMLFactory</span> { <span class="comment">/*…*/</span> }
</code></pre><p>Zuletzt muss man die <code>makeItemHTML</code> Funktion in der <code>ThemeNameHTMLFactory</code> anpassen, damit diese auch die CSS Dateien verlinkt. Das sollte dann so aussehen:</p><pre><code><span class="keyword">func</span> makeItemHTML(for item: <span class="type">Item</span>&lt;<span class="type">Site</span>&gt;,
                  context: <span class="type">PublishingContext</span>&lt;<span class="type">Site</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
  <span class="type">HTML</span>(
    .<span class="call">lang</span>(context.<span class="property">site</span>.<span class="property">language</span>),
    .<span class="call">head</span>(
      for: item,
      on: context.<span class="property">site</span>,
      stylesheetPaths: [
        <span class="string">"/styles.css"</span>,
        <span class="string">"/splash.css"</span>
      ]
    ),
    <span class="comment">/* Code ausgelassen */</span>
  )
}
</code></pre><p>Sollte ihr die CSS Datei für das Splash Plugin anders genannt haben müsst ihr das natürlich auch anpassen.</p><p>Wenn man die Seite nun neu generiert (<code>⌘ + R</code>) sieht man: nichts. Denn bisher nutzt die Publishing Pipeline immer noch die Foundation Theme. In der <code>main.swift</code> muss man noch das <code>withTheme: .foundation</code> ändern:</p><pre><code><span class="keyword">try</span> <span class="type">OddmagnetDev</span>().<span class="call">publish</span>(using: [
    .<span class="call">installPlugin</span>(.<span class="call">splash</span>(withClassPrefix: <span class="string">""</span>)),
  	<span class="comment">/* Schritte ausgelassen */</span> 
    .<span class="call">generateHTML</span>(withTheme: .<span class="dotAccess">themeName</span>),
  	<span class="comment">/* Schritte ausgelasse */</span>
])
</code></pre><p>Noch ein letztes Mal die Seite neu generieren und die Code-Blöcke sollten nun schön markiert sein.</p><p>In dem nächsten Artikel geht es dann darum, wie man sich eine eigene Theme erstellt.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://oddmagnet.dev/posts/Die%20Erstellung%20dieser%20Seite%20-%20Teil%201</guid><title>Eine deutsche Webseite über Swift, erstellt mit Swift - Teil 1</title><description>Wie diese Seite erstellt wurde, Teil 1.</description><link>https://oddmagnet.dev/posts/Die%20Erstellung%20dieser%20Seite%20-%20Teil%201</link><pubDate>Tue, 8 Feb 2022 16:22:00 +0100</pubDate><content:encoded><![CDATA[<h1>Eine deutsche Webseite über Swift, erstellt mit Swift - Teil 1</h1><h2>Ein kleines Vorwort</h2><p>Bevor es zum eigentlich Post geht wollte ich erstmal kurz meine Gründe für die Erstellung dieser Webseite nennen, damit wisst ihr (die Leser) direkt womit ihr hier rechnen könnt:</p><ul><li>Ich wollte gerne eine eigene Webseite haben, die mithilfe von <code>Markdown</code> Dateien und Swift erstellt wird</li><li>Andere deutschsprachige Seiten zu Swift scheinen inaktiv zu sein, daher die Entscheidung auf deutsch zu schreiben</li><li>Bisher kenne ich persönlich keine anderen deutschen Swift-Entwickler, vielleicht lerne ich so ja ein paar kennen</li><li>Ich bin kein Experte was iOS-Entwicklung angeht, dennoch möchte ich Sachen die ich lerne und interessant finde hier teilen, Feedback ist natürlich gerne gesehen</li><li>Hoffentlich hilft diese Sideproject auch ein wenig dabei eine Firma zu finden die mir trotz meiner Krankheitsgeschichte eine Chance gibt :)</li></ul><h2>Erste Schritte</h2><p>Eine letzte Sache noch bevor es losgeht, diese Reihe an Blogposts ist mehr eine Zusammenfassung meiner Auseinandersetzung mit dem <a href="https://github.com/JohnSundell/Publish">Publish</a> Projekt von <a href="https://github.com/JohnSundell/">John Sundell</a>, wer also lieber etwas ausführlicheres auf englisch lesen möchte sollte dort mal reinschauen. Generell wird diese Reihe von Posts eher auf einem Anfänger-Niveau sein.</p><h3>Publish installieren</h3><p>Grundsätzlich hat man zwei Möglichkeiten wie man Publish nutzen kann, entweder man fügt es über den Swift Package Manager zu einem bestehenden Projekt hinzu, oder man nutzt das Kommandozeilen Tool um ein neues Projekt zu erstellen. Für dieses Projekt nutze ich letztere Möglichkeit.</p><p>Das Kommandozeilen Tool kann man auf 2 Wegen installieren, durch das klonen des <a href="https://github.com/JohnSundell/Publish">Publish</a> Repositories und dem ausführen der <code>makefile</code>:</p><pre><code class="language-bash">$ git clone https://github.com/JohnSundell/Publish.git
$ cd Publish
$ make
</code></pre><p>Oder durch die Installation mit <a href="https://brew.sh">Brew</a>.</p><pre><code class="language-bash">$ brew install publish
</code></pre><p>Persönlich bin ich ein großer Fan von Brew, daher habe ich selber diese Variante gewählt.</p><h3>Ein neues Projekt erstellen</h3><p>Nachdem das Kommandozeilen Tool installiert ist braucht es nur noch einen neuen, leeren Ordner für das Projekt</p><pre><code class="language-bash">$ mkdir PROJEKT-NAME
$ cd PROJEKT-NAME
$ publish new
</code></pre><p>Jetzt kann man die von Publish generierte <code>Package.swift</code> Datei öffnen</p><pre><code class="language-bash">$ open Package.swift
</code></pre><p>Alternativ kann man die Datei natürlich auch einfach doppelklicken.</p><p>Jetzt kann man das Projekt auch schon direkt ausführen, mit <code>⌘+R</code> oder über <code>Product &gt; Run</code>. Wenn man das zum ersten Mal macht kommt eventuell noch eine kurze Abfrage für die Nutzung der "Command Line Tools" und noch eine für den Zugriff auf den Ordner in dem der Projekt-Ordner ist.</p><p>Wenn alles geklappt hat sollte man in Xcode folgenden Output bekommen</p><pre><code class="language-bash">Publishing PROJEKTNAME (6 steps)
[1/6] Copy 'Resources' files
[2/6] Add Markdown files from 'Content' folder
[3/6] Sort items
[4/6] Generate HTML
[5/6] Generate RSS feed
[6/6] Generate site map
✅ Successfully published PROJEKTNAME
Program ended with exit code: 0
</code></pre><h3>Lokal entwickeln und testen</h3><p>Damit man die Webseite auch direkt anschauen kann hat Publish auch ein Kommando:</p><pre><code class="language-bash">$ publish run
</code></pre><p>Beim ersten Ausführen ladet sich das Tool erstmal so einige Dateien von Github, kompiliert diese und generiert schlussendlich auch die Webseite, diese kann man dann über <code>http://localhost:8000</code> erreichen.</p><p>Um den Inhalt der Seiten neu zu generieren während der Server läuft nutzt man einfach wieder <code>Product &gt; Run</code> in Xcode.</p><h3>Webseite online verfügbar machen</h3><p>Um die Webseite dann im Internet verfügbar zu machen nutzt man den <code>deploy</code> schritt in der Publishing Pipeline. In der <code>main.swift</code> Datei (im <code>Sources &gt; PROJEKTNAME</code> Ordner) ändert man dazu</p><pre><code><span class="keyword">try</span> <span class="type">PROJEKTNAME</span>().<span class="call">publish</span>(withTheme: .<span class="dotAccess">foundation</span>)
</code></pre><p>zu</p><pre><code><span class="keyword">try</span> <span class="type">PROJEKTNAME</span>().<span class="call">publish</span>(using: [
    .<span class="call">copyResources</span>(),
    .<span class="call">addMarkdownFiles</span>(),
    .<span class="call">sortItems</span>(by: \.<span class="property">date</span>),
    .<span class="call">generateHTML</span>(withTheme: .<span class="dotAccess">foundation</span>),
    .<span class="call">generateRSSFeed</span>(including: [.<span class="dotAccess">posts</span>]),
    .<span class="call">generateSiteMap</span>(),
    .<span class="call">deploy</span>(using: .<span class="call">gitHub</span>(<span class="string">"USERNAME/PROJEKT-NAME"</span>), branch: <span class="string">"main"</span>)
])
</code></pre><p>Im obigen Beispiel wurden einfach alle Schritte die bei <code>.publish(withTheme: .foundation)</code> ausgeführt wurden auch wieder gelistet. Generell sind die Schritte optional, wer beispielsweise kein RSS Feed haben will kann den Schritt dafür einfach weglassen.</p><p>Der für diesen Teil des Beitrags relevante <code>deploy</code> Schritt wird allerdings nur ausgeführt wenn das <code>--deploy</code> flag vorhanden ist. Das kann man dann entweder direkt über die Kommandozeile machen:</p><pre><code class="language-bash">$ publish deploy
</code></pre><p>Oder indem man das <code>Scheme</code> in Xcode ändert, <code>Product &gt; Scheme &gt; Edit Scheme…</code>.</p><p>Persönlich nutze ich dafür immer die Kommandozeile, denn so gehe ich wirklich sicher dass ich nicht aus Versehen irgendwelche Änderungen veröffentliche bevor diese wirklich fertig sind.</p><p>Eine Sache die ich für meine Webseite noch zusätzlich gemacht habe, ist ein weiterer Branch, <code>author</code>, in dem sich dann sowohl die <code>.md</code> Dateien wie auch die Quelldateien für meine Webseite befinden. Änderungen kann ich so erst lokal testen bis ich zufrieden bin, dann den <code>author</code> branch comitten und über <code>publish deploy</code> wird die generierte Seite dann auf den <code>main</code> branch gepushed.</p>]]></content:encoded></item></channel></rss>